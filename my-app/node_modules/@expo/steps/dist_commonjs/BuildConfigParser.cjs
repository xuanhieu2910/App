"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuildConfigParser = void 0;
const assert_1 = __importDefault(require("assert"));
const BuildConfig_js_1 = require("./BuildConfig.cjs");
const BuildFunction_js_1 = require("./BuildFunction.cjs");
const BuildStep_js_1 = require("./BuildStep.cjs");
const BuildStepInput_js_1 = require("./BuildStepInput.cjs");
const BuildStepOutput_js_1 = require("./BuildStepOutput.cjs");
const BuildWorkflow_js_1 = require("./BuildWorkflow.cjs");
const BuildWorkflowValidator_js_1 = require("./BuildWorkflowValidator.cjs");
const errors_js_1 = require("./errors.cjs");
const duplicates_js_1 = require("./utils/expodash/duplicates.cjs");
const uniq_js_1 = require("./utils/expodash/uniq.cjs");
class BuildConfigParser {
    constructor(ctx, { configPath, externalFunctions }) {
        this.ctx = ctx;
        this.validateExternalFunctions(externalFunctions);
        this.configPath = configPath;
        this.externalFunctions = externalFunctions;
    }
    async parseAsync() {
        const config = await (0, BuildConfig_js_1.readAndValidateBuildConfigAsync)(this.configPath, {
            externalFunctionIds: this.getExternalFunctionFullIds(),
        });
        const configBuildFunctions = this.createBuildFunctionsFromConfig(config.functions);
        const buildFunctions = this.mergeBuildFunctionsWithExternal(configBuildFunctions, this.externalFunctions);
        const buildSteps = config.build.steps.map((stepConfig) => this.createBuildStepFromConfig(stepConfig, buildFunctions));
        const workflow = new BuildWorkflow_js_1.BuildWorkflow(this.ctx, { buildSteps, buildFunctions });
        new BuildWorkflowValidator_js_1.BuildWorkflowValidator(workflow).validate();
        return workflow;
    }
    createBuildStepFromConfig(buildStepConfig, buildFunctions) {
        if ((0, BuildConfig_js_1.isBuildStepCommandRun)(buildStepConfig)) {
            return this.createBuildStepFromBuildStepCommandRun(buildStepConfig);
        }
        else if ((0, BuildConfig_js_1.isBuildStepBareCommandRun)(buildStepConfig)) {
            return this.createBuildStepFromBuildStepBareCommandRun(buildStepConfig);
        }
        else if ((0, BuildConfig_js_1.isBuildStepBareFunctionCall)(buildStepConfig)) {
            return this.createBuildStepFromBuildStepBareFunctionCall(buildFunctions, buildStepConfig);
        }
        else {
            return this.createBuildStepFromBuildStepFunctionCall(buildFunctions, buildStepConfig);
        }
    }
    createBuildStepFromBuildStepCommandRun({ run }) {
        const { id: maybeId, inputs: inputsConfig, outputs: outputsConfig, name, workingDirectory, shell, command, } = run;
        const id = BuildStep_js_1.BuildStep.getNewId(maybeId);
        const displayName = BuildStep_js_1.BuildStep.getDisplayName({ id, name, command });
        const inputs = inputsConfig && this.createBuildStepInputsFromDefinition(inputsConfig, displayName);
        const outputs = outputsConfig && this.createBuildStepOutputsFromDefinition(outputsConfig, displayName);
        return new BuildStep_js_1.BuildStep(this.ctx, {
            id,
            inputs,
            outputs,
            name,
            displayName,
            workingDirectory,
            shell,
            command,
        });
    }
    createBuildStepFromBuildStepBareCommandRun({ run: command, }) {
        const id = BuildStep_js_1.BuildStep.getNewId();
        const displayName = BuildStep_js_1.BuildStep.getDisplayName({ id, command });
        return new BuildStep_js_1.BuildStep(this.ctx, {
            id,
            displayName,
            command,
        });
    }
    createBuildStepFromBuildStepBareFunctionCall(buildFunctions, functionId) {
        const buildFunction = buildFunctions[functionId];
        return buildFunction.createBuildStepFromFunctionCall(this.ctx);
    }
    createBuildStepFromBuildStepFunctionCall(buildFunctions, buildStepFunctionCall) {
        const keys = Object.keys(buildStepFunctionCall);
        (0, assert_1.default)(keys.length === 1, 'There must be at most one function call in the step (enforced by joi).');
        const functionId = keys[0];
        const buildFunctionCallConfig = buildStepFunctionCall[functionId];
        const buildFunction = buildFunctions[functionId];
        return buildFunction.createBuildStepFromFunctionCall(this.ctx, {
            id: buildFunctionCallConfig.id,
            name: buildFunctionCallConfig.name,
            callInputs: buildFunctionCallConfig.inputs,
            workingDirectory: buildFunctionCallConfig.workingDirectory,
            shell: buildFunctionCallConfig.shell,
        });
    }
    createBuildFunctionsFromConfig(buildFunctionsConfig) {
        if (!buildFunctionsConfig) {
            return {};
        }
        const result = {};
        for (const [functionId, buildFunctionConfig] of Object.entries(buildFunctionsConfig)) {
            const buildFunction = this.createBuildFunctionFromConfig({
                id: functionId,
                ...buildFunctionConfig,
            });
            result[buildFunction.getFullId()] = buildFunction;
        }
        return result;
    }
    createBuildFunctionFromConfig({ id, name, inputs: inputsConfig, outputs: outputsConfig, shell, command, supportedRuntimePlatforms, }) {
        const inputProviders = inputsConfig && this.createBuildStepInputProvidersFromBuildFunctionInputs(inputsConfig);
        const outputProviders = outputsConfig && this.createBuildStepOutputProvidersFromBuildFunctionOutputs(outputsConfig);
        return new BuildFunction_js_1.BuildFunction({
            id,
            name,
            inputProviders,
            outputProviders,
            shell,
            command,
            supportedRuntimePlatforms,
        });
    }
    createBuildStepInputsFromDefinition(buildStepInputs, stepDisplayName) {
        return Object.entries(buildStepInputs).map(([key, value]) => new BuildStepInput_js_1.BuildStepInput(this.ctx, {
            id: key,
            stepDisplayName,
            defaultValue: value,
            required: true,
            allowedValueTypeName: typeof value,
        }));
    }
    createBuildStepInputProvidersFromBuildFunctionInputs(buildFunctionInputs) {
        return buildFunctionInputs.map((entry) => {
            var _a;
            return typeof entry === 'string'
                ? BuildStepInput_js_1.BuildStepInput.createProvider({ id: entry })
                : BuildStepInput_js_1.BuildStepInput.createProvider({
                    id: entry.name,
                    required: (_a = entry.required) !== null && _a !== void 0 ? _a : true,
                    defaultValue: entry.defaultValue,
                    allowedValues: entry.allowedValues,
                    allowedValueTypeName: entry.allowedValueType,
                });
        });
    }
    createBuildStepOutputsFromDefinition(buildStepOutputs, stepDisplayName) {
        return buildStepOutputs.map((entry) => {
            var _a;
            return typeof entry === 'string'
                ? new BuildStepOutput_js_1.BuildStepOutput(this.ctx, { id: entry, stepDisplayName, required: true })
                : new BuildStepOutput_js_1.BuildStepOutput(this.ctx, {
                    id: entry.name,
                    stepDisplayName,
                    required: (_a = entry.required) !== null && _a !== void 0 ? _a : true,
                });
        });
    }
    createBuildStepOutputProvidersFromBuildFunctionOutputs(buildFunctionOutputs) {
        return buildFunctionOutputs.map((entry) => {
            var _a;
            return typeof entry === 'string'
                ? BuildStepOutput_js_1.BuildStepOutput.createProvider({ id: entry, required: true })
                : BuildStepOutput_js_1.BuildStepOutput.createProvider({ id: entry.name, required: (_a = entry.required) !== null && _a !== void 0 ? _a : true });
        });
    }
    mergeBuildFunctionsWithExternal(configFunctions, externalFunctions) {
        const result = { ...configFunctions };
        if (externalFunctions === undefined) {
            return result;
        }
        for (const buildFunction of externalFunctions) {
            // functions defined in config shadow the external ones
            const fullId = buildFunction.getFullId();
            if (!(fullId in result)) {
                result[fullId] = buildFunction;
            }
        }
        return result;
    }
    validateExternalFunctions(externalFunctions) {
        if (externalFunctions === undefined) {
            return;
        }
        const externalFunctionIds = externalFunctions.map((f) => f.getFullId());
        const duplicatedExternalFunctionIds = (0, duplicates_js_1.duplicates)(externalFunctionIds);
        if (duplicatedExternalFunctionIds.length === 0) {
            return;
        }
        throw new errors_js_1.BuildStepRuntimeError(`Provided external functions with duplicated IDs: ${duplicatedExternalFunctionIds
            .map((id) => `"${id}"`)
            .join(', ')}`);
    }
    getExternalFunctionFullIds() {
        if (this.externalFunctions === undefined) {
            return [];
        }
        const ids = this.externalFunctions.map((f) => f.getFullId());
        return (0, uniq_js_1.uniq)(ids);
    }
}
exports.BuildConfigParser = BuildConfigParser;
//# sourceMappingURL=BuildConfigParser.js.map