"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateAllFunctionsExist = exports.isBuildStepBareFunctionCall = exports.isBuildStepFunctionCall = exports.isBuildStepBareCommandRun = exports.isBuildStepCommandRun = exports.mergeConfigWithImportedFunctions = exports.validateConfig = exports.readRawBuildConfigAsync = exports.readAndValidateBuildFunctionsConfigFileAsync = exports.readAndValidateBuildConfigAsync = exports.BuildConfigSchema = exports.BuildFunctionsConfigFileSchema = void 0;
const assert_1 = __importDefault(require("assert"));
const promises_1 = __importDefault(require("fs/promises"));
const path_1 = __importDefault(require("path"));
const joi_1 = __importDefault(require("joi"));
const yaml_1 = __importDefault(require("yaml"));
const errors_js_1 = require("./errors.cjs");
const BuildRuntimePlatform_js_1 = require("./BuildRuntimePlatform.cjs");
const BuildFunction_js_1 = require("./BuildFunction.cjs");
const BuildStepInput_js_1 = require("./BuildStepInput.cjs");
const BuildFunctionInputsSchema = joi_1.default.array().items(joi_1.default.alternatives().conditional(joi_1.default.ref('.'), {
    is: joi_1.default.string(),
    then: joi_1.default.string().required(),
    otherwise: joi_1.default.object({
        name: joi_1.default.string().required(),
        defaultValue: joi_1.default.when('allowedValues', {
            is: joi_1.default.exist(),
            then: joi_1.default.valid(joi_1.default.in('allowedValues')).messages({
                'any.only': '{{#label}} must be one of allowed values',
            }),
        })
            .when('allowedValueType', {
            is: BuildStepInput_js_1.BuildStepInputValueTypeName.STRING,
            then: joi_1.default.string(),
        })
            .when('allowedValueType', {
            is: BuildStepInput_js_1.BuildStepInputValueTypeName.BOOLEAN,
            then: joi_1.default.boolean(),
        })
            .when('allowedValueType', {
            is: BuildStepInput_js_1.BuildStepInputValueTypeName.NUMBER,
            then: joi_1.default.number(),
        }),
        allowedValues: joi_1.default.when('allowedValueType', {
            is: BuildStepInput_js_1.BuildStepInputValueTypeName.STRING,
            then: joi_1.default.array().items(joi_1.default.string()),
        })
            .when('allowedValueType', {
            is: BuildStepInput_js_1.BuildStepInputValueTypeName.BOOLEAN,
            then: joi_1.default.array().items(joi_1.default.boolean()),
        })
            .when('allowedValueType', {
            is: BuildStepInput_js_1.BuildStepInputValueTypeName.NUMBER,
            then: joi_1.default.array().items(joi_1.default.number()),
        }),
        allowedValueType: joi_1.default.string()
            .valid(...Object.values(BuildStepInput_js_1.BuildStepInputValueTypeName))
            .default(BuildStepInput_js_1.BuildStepInputValueTypeName.STRING),
        required: joi_1.default.boolean(),
    })
        .rename('allowed_values', 'allowedValues')
        .rename('default_value', 'defaultValue')
        .rename('type', 'allowedValueType')
        .required(),
}));
const BuildStepOutputsSchema = joi_1.default.array().items(joi_1.default.alternatives().try(joi_1.default.string().required(), joi_1.default.object({
    name: joi_1.default.string().required(),
    required: joi_1.default.boolean(),
}).required()));
const BuildFunctionCallSchema = joi_1.default.object({
    id: joi_1.default.string(),
    inputs: joi_1.default.object().pattern(joi_1.default.string(), joi_1.default.alternatives().try(joi_1.default.string(), joi_1.default.boolean(), joi_1.default.number())),
    name: joi_1.default.string(),
    workingDirectory: joi_1.default.string(),
    shell: joi_1.default.string(),
}).rename('working_directory', 'workingDirectory');
const BuildStepConfigSchema = joi_1.default.any()
    .when(joi_1.default.object().pattern(joi_1.default.string().disallow('run').required(), joi_1.default.object().unknown().required()), {
    then: joi_1.default.object().pattern(joi_1.default.string().disallow('run').min(1).required(), BuildFunctionCallSchema.required(), { matches: joi_1.default.array().length(1) }),
})
    .when(joi_1.default.object({ run: joi_1.default.object().unknown().required() }), {
    then: joi_1.default.object({
        run: BuildFunctionCallSchema.keys({
            outputs: BuildStepOutputsSchema,
            command: joi_1.default.string().required(),
        }),
    }),
})
    .when(joi_1.default.object({ run: joi_1.default.string().required() }), {
    then: joi_1.default.object({
        run: joi_1.default.string().min(1).required(),
    }),
})
    .when(joi_1.default.string(), {
    then: joi_1.default.string().min(1),
});
const BuildFunctionConfigSchema = joi_1.default.object({
    name: joi_1.default.string(),
    supportedRuntimePlatforms: joi_1.default.array().items(...Object.values(BuildRuntimePlatform_js_1.BuildRuntimePlatform)),
    inputs: BuildFunctionInputsSchema,
    outputs: BuildStepOutputsSchema,
    command: joi_1.default.string().required(),
    shell: joi_1.default.string(),
}).rename('supported_platforms', 'supportedRuntimePlatforms');
exports.BuildFunctionsConfigFileSchema = joi_1.default.object({
    configFilesToImport: joi_1.default.array().items(joi_1.default.string().pattern(/\.y(a)?ml$/)),
    functions: joi_1.default.object().pattern(joi_1.default.string()
        .pattern(/^[\w-]+$/, 'function names')
        .min(1)
        .required()
        .disallow('run'), BuildFunctionConfigSchema.required()),
})
    .rename('import', 'configFilesToImport')
    .required();
exports.BuildConfigSchema = exports.BuildFunctionsConfigFileSchema.append({
    build: joi_1.default.object({
        name: joi_1.default.string(),
        steps: joi_1.default.array().items(BuildStepConfigSchema.required()).required(),
    }).required(),
}).required();
async function readAndValidateBuildConfigAsync(configPath, params = {}) {
    const rawConfig = await readRawBuildConfigAsync(configPath);
    const config = validateConfig(exports.BuildConfigSchema, rawConfig);
    const importedFunctions = await importFunctionsAsync(configPath, config.configFilesToImport);
    mergeConfigWithImportedFunctions(config, importedFunctions);
    validateAllFunctionsExist(config, params);
    return config;
}
exports.readAndValidateBuildConfigAsync = readAndValidateBuildConfigAsync;
async function importFunctionsAsync(baseConfigPath, configPathsToImport) {
    if (!configPathsToImport) {
        return {};
    }
    const baseConfigDir = path_1.default.dirname(baseConfigPath);
    const errors = [];
    const importedFunctions = {};
    // this is a set of visited files identified by ABSOLUTE paths
    const visitedFiles = new Set([baseConfigPath]);
    const configFilesToVisit = (configPathsToImport !== null && configPathsToImport !== void 0 ? configPathsToImport : []).map((childConfigRelativePath) => path_1.default.resolve(baseConfigDir, childConfigRelativePath));
    while (configFilesToVisit.length > 0) {
        const childConfigPath = configFilesToVisit.shift();
        (0, assert_1.default)(childConfigPath, 'Guaranteed by loop condition');
        if (visitedFiles.has(childConfigPath)) {
            continue;
        }
        visitedFiles.add(childConfigPath);
        try {
            const childConfig = await readAndValidateBuildFunctionsConfigFileAsync(childConfigPath);
            for (const functionName in childConfig.functions) {
                if (!(functionName in importedFunctions)) {
                    importedFunctions[functionName] = childConfig.functions[functionName];
                }
            }
            if (childConfig.configFilesToImport) {
                const childDir = path_1.default.dirname(childConfigPath);
                configFilesToVisit.push(...childConfig.configFilesToImport.map((relativePath) => path_1.default.resolve(childDir, relativePath)));
            }
        }
        catch (err) {
            if (err instanceof errors_js_1.BuildConfigError) {
                errors.push(err);
            }
            else {
                throw err;
            }
        }
    }
    if (errors.length > 0) {
        throw new errors_js_1.BuildWorkflowError(`Detected build config errors in imported files.`, errors);
    }
    return importedFunctions;
}
async function readAndValidateBuildFunctionsConfigFileAsync(configPath) {
    const rawConfig = await readRawBuildConfigAsync(configPath);
    return validateConfig(exports.BuildFunctionsConfigFileSchema, rawConfig);
}
exports.readAndValidateBuildFunctionsConfigFileAsync = readAndValidateBuildFunctionsConfigFileAsync;
async function readRawBuildConfigAsync(configPath) {
    const contents = await promises_1.default.readFile(configPath, 'utf-8');
    return yaml_1.default.parse(contents);
}
exports.readRawBuildConfigAsync = readRawBuildConfigAsync;
function validateConfig(schema, config, configFilePath) {
    const { error, value } = schema.validate(config, {
        allowUnknown: false,
        abortEarly: false,
    });
    if (error) {
        const errorMessage = error.details.map(({ message }) => message).join(', ');
        throw new errors_js_1.BuildConfigError(errorMessage, {
            cause: error,
            ...(configFilePath && { metadata: { configFilePath } }),
        });
    }
    return value;
}
exports.validateConfig = validateConfig;
function mergeConfigWithImportedFunctions(config, importedFunctions) {
    var _a;
    if (Object.keys(importedFunctions).length === 0) {
        return;
    }
    config.functions = (_a = config.functions) !== null && _a !== void 0 ? _a : {};
    for (const functionName in importedFunctions) {
        if (!(functionName in config.functions)) {
            config.functions[functionName] = importedFunctions[functionName];
        }
    }
}
exports.mergeConfigWithImportedFunctions = mergeConfigWithImportedFunctions;
function isBuildStepCommandRun(step) {
    return typeof step === 'object' && typeof step.run === 'object';
}
exports.isBuildStepCommandRun = isBuildStepCommandRun;
function isBuildStepBareCommandRun(step) {
    return typeof step === 'object' && typeof step.run === 'string';
}
exports.isBuildStepBareCommandRun = isBuildStepBareCommandRun;
function isBuildStepFunctionCall(step) {
    return typeof step === 'object' && !('run' in step);
}
exports.isBuildStepFunctionCall = isBuildStepFunctionCall;
function isBuildStepBareFunctionCall(step) {
    return typeof step === 'string';
}
exports.isBuildStepBareFunctionCall = isBuildStepBareFunctionCall;
function validateAllFunctionsExist(config, { externalFunctionIds = [], skipNamespacedFunctionsCheck }) {
    const calledFunctionsSet = new Set();
    for (const step of config.build.steps) {
        if (typeof step === 'string') {
            calledFunctionsSet.add(step);
        }
        else if (!('run' in step)) {
            const keys = Object.keys(step);
            (0, assert_1.default)(keys.length === 1, 'There must be at most one function call in the step (enforced by joi).');
            calledFunctionsSet.add(keys[0]);
        }
    }
    const calledFunctions = Array.from(calledFunctionsSet);
    const externalFunctionIdsSet = new Set(externalFunctionIds);
    const nonExistentFunctions = calledFunctions.filter((calledFunction) => {
        var _a;
        if (BuildFunction_js_1.BuildFunction.isFulldIdNamespaced(calledFunction) && skipNamespacedFunctionsCheck) {
            return false;
        }
        return (!(calledFunction in ((_a = config.functions) !== null && _a !== void 0 ? _a : {})) && !externalFunctionIdsSet.has(calledFunction));
    });
    if (nonExistentFunctions.length > 0) {
        throw new errors_js_1.BuildConfigError(`Calling non-existent functions: ${nonExistentFunctions.map((f) => `"${f}"`).join(', ')}.`);
    }
}
exports.validateAllFunctionsExist = validateAllFunctionsExist;
//# sourceMappingURL=BuildConfig.js.map