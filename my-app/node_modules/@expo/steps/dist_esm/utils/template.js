import { BuildConfigError } from '../errors.js';
import { nullthrows } from './nullthrows.js';
export const BUILD_STEP_INPUT_EXPRESSION_REGEXP = /\${\s*inputs\.([\S]+)\s*}/;
export const BUILD_STEP_OUTPUT_EXPRESSION_REGEXP = /\${\s*steps\.([\S]+)\s*}/;
export function interpolateWithInputs(templateString, inputs) {
    return interpolate(templateString, BUILD_STEP_INPUT_EXPRESSION_REGEXP, inputs);
}
export function interpolateWithOutputs(templateString, fn) {
    return interpolate(templateString, BUILD_STEP_OUTPUT_EXPRESSION_REGEXP, fn);
}
function interpolate(templateString, regex, varsOrFn) {
    const matched = templateString.match(new RegExp(regex, 'g'));
    if (!matched) {
        return templateString;
    }
    let result = templateString;
    for (const match of matched) {
        const [, key] = nullthrows(match.match(regex));
        const value = typeof varsOrFn === 'function' ? varsOrFn(key) : varsOrFn[key];
        result = result.replace(match, value);
    }
    return result;
}
export function findOutputPaths(templateString) {
    const result = [];
    const matches = templateString.matchAll(new RegExp(BUILD_STEP_OUTPUT_EXPRESSION_REGEXP, 'g'));
    for (const match of matches) {
        result.push(parseOutputPath(match[1]));
    }
    return result;
}
export function parseOutputPath(outputPath) {
    const splits = outputPath.split('.');
    if (splits.length !== 2) {
        throw new BuildConfigError(`Step output path must consist of two components joined with a dot, where first is the step ID, and second is the output name, e.g. "step3.output1". Passed: "${outputPath}"`);
    }
    const [stepId, outputId] = splits;
    return { stepId, outputId };
}
//# sourceMappingURL=template.js.map